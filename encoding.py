import numpy as np
import pandas as pd
from sklearn.decomposition import PCA
from sklearn.preprocessing import normalize

AMINO_ACIDS = ['A', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'Y', 'X']

"""
table of dimension in each type encoding
zScales
VHSE
PCscores
sScales
one-hot-encoding
five-bit-encoding
six-bit-encoding
hedrohobicity matrix
"""


"""
not use
zScales, VHSE, cristian, tanaka_sheraga
"""
class Encoding():
    # TODO :  MutInd Descriptor
    def __init__(self):
#         self.aaindex = pd.read_csv('./dataset/aaindex_data.csv')
        self.aaindex = pd.read_csv('/home/kyung/Plastic/plastic_model/tools/aaindex_data.csv')

    def zScales(self, data):
        """
            paper : New Chemical Descriptors Relevant for the Design of Biologically Active Peptides. A Multivariate Characterization of 87 Amino Acids
            DOI : https://doi.org/10.1021/jm9700575
        """
        matrix = {"A": [0.24, -2.32, 0.60, -0.14, 1.30], "R": [3.52, 2.50, -3.50, 1.99, -0.17],
                  "N": [3.05, 1.62, 1.04, -1.15, 1.61], "D": [3.98, 0.93, 1.93, -2.46, 0.75],
                  "C": [0.84, -1.67, 3.71, 0.18, -2.65], "Q": [1.75, 0.50, -1.44, -1.34, 0.66],
                  "E": [3.11, 0.26, -0.11, -3.04, -0.25], "G": [2.05, -4.06, 0.36, -0.82, -0.38],
                  "H": [2.47, 1.95, 0.26, 3.90, 0.09], "I": [-3.89, -1.73, -1.71, -0.84, 0.26],
                  "L": [-4.28, -1.30, -1.49, -0.72, 0.84], "K": [2.29, 0.89, -2.49, 1.49, 0.31],
                  "M": [-2.85, -0.22, 0.47, 1.94, -0.98], "F": [-4.22, 1.94, 1.06, 0.54, -0.62],
                  "P": [-1.66, 0.27, 1.84, 0.70, 2.00], "S": [2.39, -1.07, 1.15, -1.39, 0.67],
                  "T": [0.75, -2.18, -1.12, -1.46, -0.40], "W": [-4.36, 3.94, 0.59, 3.44, -1.59],
                  "Y": [-2.54, 2.44, 0.43, 0.04, -1.47], "V": [-2.59, -2.64, -1.54, -0.85, -0.02],
                  "X": [0, 0, 0, 0, 0]
                  }

        count = 0
        matrix_np = np.zeros((1000, 5), dtype=np.float64)
        for i in data:
            if count >= 1000:
                break
            else:
                matrix_np[count] = matrix[i]
                count += 1

        return matrix_np

    def VHSE(self, data):
        """
            paper : A new set of amino acid descriptors and its application in peptide QSARs
            DOI : https://doi.org/10.1002/bip.20296
        """
        matrix = {"A": [0.15, -1.11, -1.35, -0.92, 0.02, -0.91, 0.36, -0.48],
                  "R": [-1.47, 1.45, 1.24, 1.27, 1.55, 1.47, 1.30, 0.83],
                  "N": [-0.99, 0.00, -0.37, 0.69, -0.55, 0.85, 0.73, -0.80],
                  "D": [-1.15, 0.67, -0.41, -0.01, -2.68, 1.31, 0.03, 0.56],
                  "C": [0.18, -1.67, -0.46, -0.21, 0.00, 1.20, -1.61, -0.19],
                  "Q": [-0.96, 0.12, 0.18, 0.16, 0.09, 0.42, -0.20, -0.41],
                  "E": [-1.18, 0.40, 0.10, 0.36, -2.16, -0.17, 0.91, 0.02],
                  "G": [-0.20, -1.53, -2.63, 2.28, -0.53, -1.18, 2.01, -1.34],
                  "H": [-0.43, -0.25, 0.37, 0.19, 0.51, 1.28, 0.93, 0.65],
                  "I": [1.27, -0.14, 0.30, -1.80, 0.30, -1.61, -0.16, -0.13],
                  "L": [1.36, 0.07, 0.26, -0.80, 0.22, -1.37, 0.08, -0.62],
                  "K": [-1.17, 0.70, 0.70, 0.80, 1.64, 0.67, 1.63, 0.13],
                  "M": [1.01, -0.53, 0.43, 0.00, 0.23, 0.10, -0.86, -0.68],
                  "F": [1.52, 0.61, 0.96, -0.16, 0.25, 0.28, -1.33, -0.20],
                  "P": [0.22, -0.17, -0.50, 0.05, -0.01, -1.34, -0.19, 3.56],
                  "S": [-0.67, -0.86, -1.07, -0.41, -0.32, 0.27, -0.64, 0.11],
                  "T": [-0.34, -0.51, -0.55, -1.06, -0.06, -0.01, -0.79, 0.39],
                  "W": [1.50, 2.06, 1.79, 0.75, 0.75, -0.13, -1.01, -0.85],
                  "Y": [0.61, 1.60, 1.17, 0.73, 0.53, 0.25, -0.96, -0.52],
                  "V": [0.76, -0.92, -0.17, -1.91, 0.22, -1.40, -0.24, -0.03],
                  "X": [0, 0, 0, 0, 0, 0, 0, 0]
                  }
        
        count = 0
        matrix_np = np.zeros((1000, 8), dtype=np.float64)
        for i in data:
            if count >= 1000:
                break
            else:
                matrix_np[count] = matrix[i]
                count += 1
        
        return matrix_np

    def PCscores(self):
        # print()
        x = self.aaindex.drop(['Description'], axis=1).values[:533]
        x = np.nan_to_num(x)
        x = normalize(x)
        pca = PCA(n_components=11)

        pcscore_matrix = pca.fit_transform(x)
        return pcscore_matrix

    def sScales(self):
        """
        data_list = ['BIOV880101', 'BLAM930101', 'TANS770101', 'TSAJ990101', 'NAKH920106', 'NAKH920107', 'NAKH920108', 'CEDJ970104', 'LIFS790101' ,'LIFS790102', 'LIFS790103', 'MIYS990104', 'COWR900101', 'ARGP820101', 'DAWD720101', 'FAUJ880109']
        """
        data_list = ['BIOV880101', 'BLAM930101', 'TANS770101', 'TSAJ990101', 'NAKH920106', 'NAKH920107', 'NAKH920108',
                     'CEDJ970104', 'LIFS790101', 'LIFS790102', 'LIFS790103', 'MIYS990104', 'COWR900101', 'ARGP820101',
                     'DAWD720101', 'FAUJ880109']
        x = self.aaindex[self.aaindex['Description'].isin(data_list)]
        x = x.drop(['Description'], axis=1).values
        x = np.nan_to_num(x)
        x = normalize(x)
        pca = PCA(n_components=11)

        pcscore_matrix = pca.fit_transform(x)
        return pcscore_matrix


    def one_hot_encoding(self, data):  # same Identity descriptor
        matrix = np.zeros((1000, 21), dtype=np.float64)
        count = 0
        for i in data:
            if count >= 1000:
                break
            else:
                matrix[count][AMINO_ACIDS.index(i)] = 1
                count += 1
        return matrix

    def five_bit_encoding(self, data):
        matrix = {"A": [1, 0, 0, 0, 1], "C": [1, 0, 0, 1, 0], "D": [1, 0, 1, 0, 0],
                  "E": [1, 1, 0, 0, 0], "F": [0, 1, 0, 0, 1], "G": [0, 1, 0, 1, 0],
                  "H": [0, 1, 1, 0, 0], "I": [0, 0, 1, 0, 1], "K": [0, 0, 1, 1, 0],
                  "L": [0, 0, 0, 1, 1], "M": [0, 1, 1, 1, 0], "N": [0, 1, 1, 0, 1],
                  "P": [0, 1, 0, 1, 1], "Q": [0, 0, 1, 1, 1], "R": [1, 0, 1, 1, 0],
                  "S": [1, 0, 1, 0, 1], "T": [1, 0, 0, 1, 1], "V": [1, 1, 0, 1, 0],
                  "W": [1, 1, 0, 0, 1], "Y": [1, 1, 1, 0, 0], "X": [0, 0, 0, 0, 0]}

        count = 0
        matrix_np = np.zeros((1000, 5), dtype=np.float64)
        for i in data:
            if count >= 1000:
                break
            else:
                matrix_np[count] = matrix[i]
                count += 1
        return matrix_np

    def six_bit_encoding(self, data):
        """
        1 = [H, R, K]
        2 = [D, E, N, Q]
        3 = [C]
        4 = [S, T, P, A, G]
        5 = [M, I, L, V]
        6 = [F, Y, W]
        """
        six_bit_amino_acid = {"A": [0, 0, 0, 1, 0, 0], "C": [0, 0, 1, 0, 0, 0],
                              'D': [0, 1, 0, 0, 0, 0], 'E': [0, 1, 0, 0, 0, 0],
                              'F': [0, 0, 0, 0, 0, 1], 'G': [0, 0, 0, 1, 0, 0],
                              'H': [0, 0, 0, 0, 1, 0], 'I': [0, 0, 0, 0, 1, 0],
                              'K': [1, 0, 0, 0, 0, 0], 'L': [0, 0, 0, 0, 1, 0],
                              'M': [0, 0, 0, 0, 1, 0], 'N': [0, 1, 0, 0, 0, 0],
                              'P': [0, 0, 0, 1, 0, 0], 'Q': [0, 1, 0, 0, 0, 0],
                              'R': [1, 0, 0, 0, 0, 0], 'S': [0, 0, 0, 1, 0, 0],
                              'T': [0, 0, 0, 1, 0, 0], 'V': [0, 0, 0, 0, 1, 0],
                              'W': [0, 0, 0, 0, 0, 1], 'Y': [0, 0, 0, 0, 0, 1], 'X': [0, 0, 0, 0, 0, 0]
                              }
        count = 0
        matrix_np = np.zeros((1000, 6), dtype=np.float64)
        for i in data:
            if count >= 1000:
                break
            else:
                matrix_np[count] = matrix[i]
                count += 1
        return matrix_np

    """
    Physicochemical Properties Encoding
        Hydrophobicity matrix
        Meiler parameters
        Acthely factors
    """

    # Hydrophobicity matrix
    def hydrohobicity_matrix(self, data):
        matrix = {
            "A": [0, 0.83, 0.42, 0.52, 0.02, 0.36, 0.43, 0.04, 0.32, 0.15, 0.15, 0.36, 0.02, 0.05, 0.11, 0.26, 0.21,
                  0.02, 0.09, 0.11],
            "R": [0.83, 0, 0.41, 0.31, 0.81, 0.46, 0.4, 0.79, 0.51, 0.99, 0.99, 0.46, 0.86, 0.89, 0.94, 0.57, 0.61,
                  0.86, 0.73, 0.94],
            "N": [0.42, 0.41, 0, 0.1, 0.39, 0.05, 0, 0.37, 0.09, 0.57, 0.57, 0.05, 0.44, 0.48, 0.53, 0.16, 0.2, 0.44,
                  0.32, 0.53],
            "D": [0.52, 0.31, 0.1, 0, 0.5, 0.15, 0.09, 0.48, 0.2, 0.68, 0.68, 0.15, 0.55, 0.58, 0.63, 0.26, 0.3, 0.55,
                  0.42, 0.63],
            "C": [0.02, 0.81, 0.39, 0.5, 0, 0.34, 0.4, 0.01, 0.29, 0.18, 0.18, 0.34, 0.05, 0.08, 0.13, 0.23, 0.19, 0.05,
                  0.07, 0.13],
            "Q": [0.36, 0.46, 0.05, 0.15, 0.34, 0, 0.06, 0.32, 0.04, 0.52, 0.52, 0, 0.39, 0.42, 0.47, 0.1, 0.14, 0.39,
                  0.27, 0.47],
            "E": [0.43, 0.4, 0, 0.09, 0.4, 0.06, 0, 0.38, 0.1, 0.58, 0.58, 0.06, 0.45, 0.48, 0.54, 0.17, 0.21, 0.45,
                  0.33, 0.54],
            "G": [0.04, 0.79, 0.37, 0.48, 0.01, 0.32, 0.38, 0, 0.28, 0.19, 0.19, 0.32, 0.07, 0.1, 0.15, 0.21, 0.17,
                  0.06, 0.05, 0.15],
            "H": [0.32, 0.51, 0.09, 0.2, 0.29, 0.04, 0.1, 0.28, 0, 0.47, 0.47, 0.04, 0.35, 0.38, 0.43, 0.06, 0.1, 0.34,
                  0.22, 0.43],
            "I": [0.15, 0.99, 0.57, 0.68, 0.18, 0.52, 0.58, 0.19, 0.47, 0, 0, 0.52, 0.12, 0.09, 0.04, 0.41, 0.37, 0.12,
                  0.25, 0.04],
            "L": [0.15, 0.99, 0.57, 0.68, 0.18, 0.52, 0.58, 0.19, 0.47, 0, 0, 0.52, 0.12, 0.09, 0.04, 0.41, 0.37, 0.12,
                  0.25, 0.04],
            "K": [0.36, 0.46, 0.05, 0.15, 0.34, 0, 0.06, 0.32, 0.04, 0.52, 0.52, 0, 0.39, 0.42, 0.47, 0.1, 0.14, 0.39,
                  0.27, 0.47],
            "M": [0.02, 0.86, 0.44, 0.55, 0.05, 0.39, 0.45, 0.07, 0.35, 0.12, 0.12, 0.39, 0, 0.03, 0.08, 0.28, 0.24, 0,
                  0.12, 0.08],
            "F": [0.05, 0.89, 0.48, 0.58, 0.08, 0.42, 0.48, 0.1, 0.38, 0.09, 0.09, 0.42, 0.03, 0, 0.05, 0.31, 0.27,
                  0.03, 0.15, 0.05],
            "P": [0.11, 0.94, 0.53, 0.63, 0.13, 0.47, 0.54, 0.15, 0.43, 0.04, 0.04, 0.47, 0.08, 0.05, 0, 0.37, 0.33,
                  0.08, 0.2, 0],
            "S": [0.26, 0.57, 0.16, 0.26, 0.23, 0.1, 0.17, 0.21, 0.06, 0.41, 0.41, 0.1, 0.28, 0.31, 0.37, 0, 0.04, 0.28,
                  0.16, 0.37],
            "T": [0.21, 0.61, 0.2, 0.3, 0.19, 0.14, 0.21, 0.17, 0.1, 0.37, 0.37, 0.14, 0.24, 0.27, 0.33, 0.04, 0, 0.24,
                  0.12, 0.33],
            "W": [0.02, 0.86, 0.44, 0.55, 0.05, 0.39, 0.45, 0.06, 0.34, 0.12, 0.12, 0.39, 0, 0.03, 0.08, 0.28, 0.24, 0,
                  0.12, 0.08],
            "Y": [0.09, 0.73, 0.32, 0.42, 0.07, 0.27, 0.33, 0.05, 0.22, 0.25, 0.25, 0.27, 0.12, 0.15, 0.2, 0.16, 0.12,
                  0.12, 0, 0.2],
            "V": [0.11, 0.94, 0.53, 0.63, 0.13, 0.47, 0.54, 0.15, 0.43, 0.04, 0.04, 0.47, 0.08, 0.05, 0, 0.37, 0.33,
                  0.08, 0.2, 0],
            "X": [0.25, 0.69, 0.33, 0.41, 0.24, 0.3, 0.34, 0.24, 0.28, 0.34, 0.34, 0.3, 0.26, 0.27, 0.3, 0.26, 0.25,
                  0.26, 0.24, 0.3]}

        count = 0
        matrix_np = np.zeros((1000, 20), dtype=np.float64)
        for i in data:
            if count >= 1000:
                break
            else:
                matrix_np[count] = matrix[i]
                count += 1
        return matrix_np

    def meiler_parameters(self, data):
        matrix = {"A": [1.28, 0.05, 1.0, 0.31, 6.11, 0.42, 0.23],
                  "G": [0.0, 0.0, 0.0, 0.0, 6.07, 0.13, 0.15],
                  "V": [3.67, 0.14, 3.0, 1.22, 6.02, 0.27, 0.49],
                  "L": [2.59, 0.19, 4.0, 1.7, 6.04, 0.39, 0.31],
                  "I": [4.19, 0.19, 4.0, 1.8, 6.04, 0.3, 0.45],
                  "F": [2.94, 0.29, 5.89, 1.79, 5.67, 0.3, 0.38],
                  "Y": [2.94, 0.3, 6.47, 0.96, 5.66, 0.25, 0.41],
                  "W": [3.21, 0.41, 8.08, 2.25, 5.94, 0.32, 0.42],
                  "T": [3.03, 0.11, 2.6, 0.26, 5.6, 0.21, 0.36],
                  "S": [1.31, 0.06, 1.6, -0.04, 5.7, 0.2, 0.28],
                  "R": [2.34, 0.29, 6.13, -1.01, 10.74, 0.36, 0.25],
                  "K": [1.89, 0.22, 4.77, -0.99, 9.99, 0.32, 0.27],
                  "H": [2.99, 0.23, 4.66, 0.13, 7.69, 0.27, 0.3],
                  "D": [1.6, 0.11, 2.78, -0.77, 2.95, 0.25, 0.2],
                  "E": [1.56, 0.15, 3.78, -0.64, 3.09, 0.42, 0.21],
                  "N": [1.6, 0.13, 2.95, -0.6, 6.52, 0.21, 0.22],
                  "Q": [1.56, 0.18, 3.95, -0.22, 5.65, 0.36, 0.25],
                  "M": [2.35, 0.22, 4.43, 1.23, 5.71, 0.38, 0.32],
                  "P": [2.67, 0.0, 2.72, 0.72, 6.8, 0.13, 0.34],
                  "C": [1.77, 0.13, 2.43, 1.54, 6.35, 0.17, 0.41],
                  "X": [2.27, 0.17, 3.76, 0.48, 6.22, 0.28, 0.31]}

        count = 0
        matrix_np = np.zeros((1000, 7), dtype=np.float64)
        for i in data:
            if count >= 1000:
                break
            else:
                matrix_np[count] = matrix[i]
                count += 1
        return matrix_np

    def acthely_factors(self, data):
        acthely_factors_list = {"A": [-0.591, -1.302, -0.733, 1.57, -0.146],
                                "C": [-1.343, 0.465, -0.862, -1.02, -0.255],
                                "D": [1.05, 0.302, -3.656, -0.259, -3.242],
                                "E": [1.357, -1.453, 1.477, 0.113, -0.837],
                                "F": [-1.006, -0.59, 1.891, -0.397, 0.412],
                                "G": [-0.384, 1.652, 1.33, 1.045, 2.064],
                                "H": [0.336, -0.417, -1.673, -1.474, -0.078],
                                "I": [-1.239, -0.547, 2.131, 0.393, 0.816],
                                "K": [1.831, -0.561, 0.533, -0.277, 1.648],
                                "L": [-1.019, -0.987, -1.505, 1.266, -0.912],
                                "M": [-0.663, -1.524, 2.219, -1.005, 1.212],
                                "N": [0.945, 0.828, 1.299, -0.169, 0.933],
                                "P": [0.189, 2.081, -1.628, 0.421, -1.392],
                                "Q": [0.931, -0.179, -3.005, -0.503, -1.853],
                                "R": [1.538, -0.055, 1.502, 0.44, 2.897],
                                "S": [-0.228, 1.399, -4.76, 0.67, -2.647],
                                "T": [-0.032, 0.326, 2.213, 0.908, 1.313],
                                "V": [-1.337, -0.279, -0.544, 1.242, -1.262],
                                "W": [-0.595, 0.009, 0.672, -2.128, -0.184],
                                "Y": [0.26, 0.83, 3.097, -0.838, 1.512],
                                "X": [0.0, 0.0, 0.0, 0.0, 0.0]}

        count = 0
        matrix_np = np.zeros((1000, 5), dtype=np.float64)
        for i in data:
            if count >= 1000:
                break
            else:
                matrix_np[count] = matrix[i]
                count += 1
        return matrix_np

    """
    Evolution Based Encoding
        PAM250
        BLOSUM62
        PSSM
        HMM
    """

    # PAM250

    def pam250(self, data):
        matrix = {"A": [2, -2, 0, 0, -2, 0, 0, 1, -1, -1, -2, -1, -1, -3, 1, 1, 1, -6, -3, 0],
                  "C": [-2, -4, -4, -5, 12, -5, -5, -3, -3, -2, -6, -5, -5, -4, -3, 0, -2, -8, 0, -2],
                  "D": [0, -1, 2, 4, -5, 2, 3, 1, 1, -2, -4, 0, -3, -6, -1, 0, 0, -7, -4, -2],
                  "E": [0, -1, 1, 3, -5, 2, 4, 0, 1, -2, -3, 0, -2, -5, -1, 0, 0, -7, -4, -2],
                  "F": [-3, -4, -3, -6, -4, -5, -5, -5, -2, 1, 2, -5, 0, 9, -5, -3, -3, 0, 7, -1],
                  "G": [1, -3, 0, 1, -3, -1, 0, 5, -2, -3, -4, -2, -3, -5, 0, 1, 0, -7, -5, -1],
                  "H": [-1, 2, 2, 1, -3, 3, 1, -2, 6, -2, -2, 0, -2, -2, 0, -1, -1, -3, 0, -2],
                  "I": [-1, -2, -2, -2, -2, -2, -2, -3, -2, 5, 2, -2, 2, 1, -2, -1, 0, -5, -1, 4],
                  "K": [-1, 3, 1, 0, -5, 1, 0, -2, 0, -2, -3, 5, 0, -5, -1, 0, 0, -3, -4, -2],
                  "L": [-2, -3, -3, -4, -6, -2, -3, -4, -2, 2, 6, -3, 4, 2, -3, -3, -2, -2, -1, 2],
                  "M": [-1, 0, -2, -3, -5, -1, -2, -3, -2, 2, 4, 0, 6, 0, -2, -2, -1, -4, -2, 2],
                  "N": [0, 0, 2, 2, -4, 1, 1, 0, 2, -2, -3, 1, -2, -3, 0, 1, 0, -4, -2, -2],
                  "P": [1, 0, 0, -1, -3, 0, -1, 0, 0, -2, -3, -1, -2, -5, 6, 1, 0, -6, -5, -1],
                  "Q": [0, 1, 1, 2, -5, 4, 2, -1, 3, -2, -2, 1, -1, -5, 0, -1, -1, -5, -4, -2],
                  "R": [-2, 6, 0, -1, -4, 1, -1, -3, 2, -2, -3, 3, 0, -4, 0, 0, -1, 2, -4, -2],
                  "S": [1, 0, 1, 0, 0, -1, 0, 1, -1, -1, -3, 0, -2, -3, 1, 2, 1, -2, -3, -1],
                  "T": [1, -1, 0, 0, -2, -1, 0, 0, -1, 0, -2, 0, -1, -3, 0, 1, 3, -5, -3, 0],
                  "V": [0, -2, -2, -2, -2, -2, -2, -1, -2, 4, 2, -2, 2, -1, -1, -1, 0, -6, -2, 4],
                  "W": [-6, 2, -4, -7, -8, -5, -7, -7, -3, -5, -2, -3, -4, 0, -6, -2, -5, 17, 0, -6],
                  "Y": [-3, -4, -2, -4, 0, -4, -4, -5, 0, -1, -1, -4, -2, 7, -5, -3, -3, 0, 10, -2],
                  "X": [-0.8, -0.65, -0.6, -1.1, -2.8, -0.75, -1.05, -1.55, -0.3, -0.75, -1.35, -0.9, -0.8, -1.75, -1.1,
                        -0.5, -0.7, -3.05, -1.5, -0.8]
                  }

        count = 0
        matrix_np = np.zeros((1000, 20), dtype=np.float64)
        for i in data:
            if count >= 1000:
                break
            else:
                matrix_np[count] = matrix[i]
                count += 1
        return matrix_np

    def blosum62(self, data):
        matrix = {"A": [4, -1, -2, -2, 0, -1, -1, 0, -2, -1, -1, -1, -1, -2, -1, 1, 0, -3, -2, 0],
                  "C": [0, -3, -3, -3, 9, -3, -4, -3, -3, -1, -1, -3, -1, -2, -3, -1, -1, -2, -2, -1],
                  "D": [-2, -2, 1, 6, -3, 0, 2, -1, -1, -3, -4, -1, -3, -3, -1, 0, -1, -4, -3, -3],
                  "E": [-1, 0, 0, 2, -4, 2, 5, -2, 0, -3, -3, 1, -2, -3, -1, 0, -1, -3, -2, -2],
                  "F": [-2, -3, -3, -3, -2, -3, -3, -3, -1, 0, 0, -3, 0, 6, -4, -2, -2, 1, 3, -1],
                  "G": [0, -2, 0, -1, -3, -2, -2, 6, -2, -4, -4, -2, -3, -3, -2, 0, -2, -2, -3, -3],
                  "H": [-2, 0, 1, -1, -3, 0, 0, -2, 8, -3, -3, -1, -2, -1, -2, -1, -2, -2, 2, -3],
                  "I": [-1, -3, -3, -3, -1, -3, -3, -4, -3, 4, 2, -3, 1, 0, -3, -2, -1, -3, -1, 3],
                  "K": [-1, 2, 0, -1, -3, 1, 1, -2, -1, -3, -2, 5, -1, -3, -1, 0, -1, -3, -2, -2],
                  "L": [-1, -2, -3, -4, -1, -2, -3, -4, -3, 2, 4, -2, 2, 0, -3, -2, -1, -2, -1, 1],
                  "M": [-1, -1, -2, -3, -1, 0, -2, -3, -2, 1, 2, -1, 5, 0, -2, -1, -1, -1, -1, 1],
                  "N": [-2, 0, 6, 1, -3, 0, 0, 0, 1, -3, -3, 0, -2, -3, -2, 1, 0, -4, -2, -3],
                  "P": [-1, -2, -2, -1, -3, -1, -1, -2, -2, -3, -3, -1, -2, -4, 7, -1, -1, -4, -3, -2],
                  "Q": [-1, 1, 0, 0, -3, 5, 2, -2, 0, -3, -2, 1, 0, -3, -1, 0, -1, -2, -1, -2],
                  "R": [-1, 5, 0, -2, -3, 1, 0, -2, 0, -3, -2, 2, -1, -3, -2, -1, -1, -3, -2, -3],
                  "S": [1, -1, 1, 0, -1, 0, 0, 0, -1, -2, -2, 0, -1, -2, -1, 4, 1, -3, -2, -2],
                  "T": [0, -1, 0, -1, -1, -1, -1, -2, -2, -1, -1, -1, -1, -2, -1, 1, 5, -2, -2, 0],
                  "V": [0, -3, -3, -3, -1, -2, -2, -3, -3, 3, 1, -2, 1, -1, -2, -2, 0, -3, -1, 4],
                  "W": [-3, -3, -4, -4, -2, -2, -3, -2, -2, -3, -2, -3, -1, 1, -4, -3, -2, 11, 2, -3],
                  "Y": [-2, -2, -2, -3, -2, -1, -2, -3, 2, -1, -1, -2, -1, 3, -3, -2, -2, 2, 7, -1],
                  "X": [-0.8, -1.1, -0.95, -1.35, -1.65, -0.65, -0.9, -1.75, -0.9, -1.4, -1.3, -0.9, -0.7, -1.3, -1.7,
                        -0.55, -0.7, -1.7, -0.85, -1.15]
                  }

        count = 0
        matrix_np = np.zeros((1000, 20), dtype=np.float64)
        for i in data:
            if count >= 1000:
                break
            else:
                matrix_np[count] = matrix[i]
                count += 1
        return matrix_np

    # PSSM or HMM using created tools
    def pssm(self, data):
        from Bio import Seq, motifs
        instances = []
        for i in data:
            instances.append(Seq.Seq(i))
        m = motifs.create(instances, AMINO_ACIDS)
        m.pseudocounts = 1 / 21
        pssm_data = m.pssm
        
        return np.array(pssm_data)

    def hmm(self, data):
        from Bio import Seq, motifs
        instances = []
        for i in data:
            instances.append(Seq.Seq(i))
        m = motifs.create(instances, AMINO_ACIDS)
        m.pseudocounts = 1 / 21
        hmm_data = m.pssm
        return np.array(hmm_data)

    """
    Structure Based Encoding
        Miyazawa energies
        Micheletti potentials

        Tanaka Scheraga - Medium- and long-range interaction parameters between amino acids for predicting three-dimensional structures of proteins
        Skolnick - Derivation and testing of pair potentials for protein folding. When is the quasichemical approximation correct?
        Simons - Improved recognition of nativelike protein structures using a combination of sequencedependent and sequenceindependent features of proteins, are not include matrix
        Zhang and Kim - Environment-dependent residue contact energies for proteins, i don't know what using which matrix better.
        Cristian - Learning effective amino acid interactions through iterative stochastic techniques
    """

    def cristian(self, data):
        matrix = {
            "G": [0.000990, -0.003111, 0.001995, -0.001538, 0.000446, 0.001847, 0.002339, 0.000189, 0.009071, -0.000737,
                  -0.000951, -0.012366, -0.003528, 0.001084, -0.001309, 0.002466, 0.001528, -0.001649, -0.000113,
                  -0.000425],
            "A": [-0.000425, -0.001461, 0.003642, 0.000864, -0.002119, -0.000751, -0.001496, 0.005126, -0.005081,
                  -0.000724, -0.002432, -0.009737, -0.001515, -0.000218, 0.001754, -0.002511, -0.001348, 0.003323,
                  -0.002376, 0.005029],
            "V": [-0.000113, -0.002376, 0.001455, -0.001940, 0.002618, 0.000296, -0.005331, 0.000008, 0.001362,
                  -0.002175, -0.006893, -0.001516, -0.000443, 0.004075, -0.006987, -0.005168, 0.000092, -0.001040,
                  0.001387, 0.000029],
            "L": [-0.001649, -0.002376, 0.000029, -0.000748, -0.000782, -0.000196, -0.002531, -0.002127, -0.005026,
                  0.003540, -0.004529, 0.010659, 0.001004, 0.003770, 0.002119, -0.001302, 0.000585, -0.000605,
                  -0.000453, -0.004168],
            "I": [0.002466, -0.001348, -0.001040, -0.000453, 0.006801, 0.002965, -0.009283, -0.009792, 0.004353,
                  -0.004792, -0.000476, 0.002734, 0.001538, -0.004179, 0.000855, 0.001034, 0.002659, 0.002317, 0.007647,
                  -0.001875],
            "C": [-0.001309, -0.002511, 0.000092, -0.000605, 0.007647, -0.002544, 0.014331, 0.013925, -0.001720,
                  0.002585, 0.054553, -0.35239, 0.001837, 0.002620, -0.006040, -0.006062, 0.002278, 0.006139, 0.002791,
                  0.001387],
            "M": [0.001084, 0.001754, -0.005168, 0.000585, 0.002317, 0.002791, 0.031655, 0.001010, -0.008698, -0.003258,
                  0.031785, 0.984886, 0.002007, -0.002190, -0.004667, -0.004676, -0.001491, 0.018413, 0.003231,
                  -0.002908],
            "F": [-0.003528, -0.000218, -0.006987, -0.001302, 0.002659, 0.006139, 0.003231, -0.013128, -0.006986,
                  -0.003256, -0.000190, 0.006057, -0.001223, 0.004102, -0.004479, 0.004855, 0.004899, 0.003461,
                  -0.001134, 0.003790],
            "P": [-0.012366, -0.001515, 0.004075, 0.002119, 0.001034, 0.002278, 0.018413, -0.001134, -0.003621,
                  0.000996, -0.002032, 0.013914, -0.003125, 0.005402, 0.009888, -0.000067, 0.000755, 0.003707, 0.005402,
                  0.000525],
            "Y": [-0.000951, -0.009737, -0.000443, 0.003770, 0.000855, -0.006062, -0.001491, 0.003461, 0.005402,
                  -0.007699, 0.007276, 0.003708, -0.001895, -0.001235, 0.007965, 0.004237, 0.000182, -0.006968,
                  0.003261, -0.005137],
            "H": [-0.000737, -0.002432, 0.001526, 0.001004, -0.004179, 0.006040, 0.004676, 0.004899, 0.003707, 0.003261,
                  0.001314, -0.006739, 0.009858, -0.005871, 0.002932, 0.009985, -0.002501, 0.008099, -0.007232,
                  0.005803],
            "W": [0.009071, -0.000724, -0.006893, 0.010659, 0.001538, 0.002620, -0.004667, 0.004855, 0.000744,
                  -0.006968, -0.007232, 0.131813, -0.002330, 0.003848, -0.001668, -0.014845, -0.007832, -0.003028,
                  -0.009357, 0.012075],
            "S": [0.000189, -0.005081, -0.002175, -0.004529, 0.002734, 0.001837, -0.002190, -0.004479, -0.000067,
                  0.000182, 0.008099, -0.007832, -0.000802, -0.002393, 0.005015, -0.001180, -0.001609, 0.006249,
                  0.002888, -0.009002],
            "T": [0.002339, 0.005126, 0.001362, 0.003540, -0.000476, -0.35239, 0.002007, 0.004102, 0.009888, 0.004237,
                  -0.0025001, -0.003028, 0.002888, 0.003269, -0.005895, 0.003967, 0.002193, -0.005914, 0.000948,
                  0.001006],
            "K": [0.001847, -0.001496, 0.000008, -0.005026, -0.004792, 0.054553, 0.984886, -0.001223, 0.005402,
                  0.007965, 0.009985, -0.007832, 0.006249, 0.000948, 0.005109, 0.007273, -0.000642, 0.006158, -0.009604,
                  0.002349],
            "R": [0.000446, -0.000751, -0.005331, -0.002127, 0.004353, 0.002585, 0.031785, 0.006057, -0.003125,
                  -0.001235, 0.002932, -0.014845, -0.001609, -0.005914, -0.009604, 0.009875, 0.001974, -0.006728,
                  -0.004586, -0.001210],
            "D": [-0.001538, -0.002119, 0.000296, -0.002531, -0.009792, -0.001720, -0.003258, -0.000190, 0.013914,
                  -0.001895, -0.005871, -0.001668, -0.001180, 0.002193, 0.006158, -0.004586, -0.000531, 0.007855,
                  0.002194, -0.001466],
            "N": [0.001995, 0.000864, 0.002618, -0.000196, -0.009283, 0.013925, -0.008698, -0.003256, -0.002032,
                  0.003708, 0.009858, 0.003848, 0.005015, 0.003967, -0.000642, -0.006728, 0.002104, -0.001962,
                  -0.003154, 0.004502],
            "E": [-0.003111, 0.003642, -0.001940, -0.000782, 0.002965, 0.014331, 0.001010, -0.006986, 0.000996,
                  0.007276, -0.006739, -0.002330, -0.002393, -0.005895, 0.007273, 0.001974, 0.007855, 0.006456,
                  -0.003154, -0.005234],
            "Q": [0.000990, -0.001461, 0.001455, -0.000748, 0.006801, -0.002544, 0.031655, -0.013128, -0.003621,
                  -0.007699, -0.001314, 0.131813, -0.000802, 0.003269, 0.005109, 0.009875, -0.000531, -0.001962,
                  0.006456, 0.008438],
            "X": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            }

        count = 0
        matrix_np = np.zeros((1000, 20), dtype=np.float64)
        for i in data:
            if count >= 1000:
                break
            else:
                matrix_np[count] = matrix[i]
                count += 1
        return matrix_np

    def tanaka_sheraga(self, data):
        matrix = {
            "A": [-2.6, -3.4, -3.1, -2.8, -4.2, -3.5, -3.0, -3.8, -4.0, -5.9, -4.8, -3.1, -4.6, -5.1, -3.4, -2.9, -3.3,
                  -5.2, -4.7, -4.3],
            "R": [-3.4, -4.3, -4.1, -3.9, -5.3, -4.5, -4.2, -4.5, -4.9, -6.2, -5.1, -3.6, -5.0, -5.8, -4.2, -3.8, -4.0,
                  -5.8, -5.6, -4.9],
            "N": [-3.1, -4.1, -3.2, -3.1, -4.9, -3.8, -3.4, -4.0, -4.4, -5.8, -4.6, -3.3, -4.2, -5.0, -3.6, -3.1, -3.5,
                  -5.3, -5.0, -4.3],
            "D": [-2.8, -3.9, -3.1, -2.7, -4.2, -3.2, -3.3, -3.7, -4.3, -5.4, -4.3, -3.2, -4.3, -4.9, -3.3, -2.7, -3.1,
                  -5.1, -4.7, -4.0],
            "C": [-4.2, -5.3, -4.9, -4.2, -7.1, -5.0, -4.4, -5.4, -5.6, -7.3, -6.2, -4.4, -6.2, -6.8, -5.3, -4.6, -4.6,
                  -6.9, -6.6, -6.0],
            "Q": [-3.5, -4.5, -4.8, -3.2, -5.0, -3.4, -3.6, -4.4, -4.7, -5.9, -5.0, -3.7, -3.5, -5.3, -4.0, -3.6, -3.7,
                  -5.8, -5.2, -4.7],
            "E": [-3.0, -4.2, -3.4, -3.3, -4.4, -4.6, -2.8, -3.8, -4.5, -5.7, -4.6, -3.8, -4.6, -5.0, -3.5, -3.2, -3.3,
                  -5.2, -4.9, -4.2],
            "G": [-3.8, -4.5, -4.0, -3.7, -5.4, -4.4, -3.8, -3.9, -4.7, -6.3, -5.2, -3.8, -5.1, -5.6, -4.2, -3.8, -4.1,
                  -5.8, -5.4, -5.1],
            "H": [-4.0, -4.9, -4.4, -4.3, -5.6, -4.7, -4.5, -4.7, -4.9, -6.6, -5.6, -4.1, -5.4, -6.4, -4.5, -4.3, -4.5,
                  -6.5, -6.1, -5.3],
            "I": [-5.9, -6.2, -5.8, -5.4, -7.3, -5.9, -5.7, -6.3, -6.6, -8.2, -7.5, -5.6, -7.4, -8.0, -6.0, -5.5, -5.9,
                  -7.8, -7.4, -7.3],
            "L": [-4.8, -5.1, -4.6, -4.3, -6.2, -5.0, -4.6, -5.2, -5.6, -7.5, -6.2, -4.6, -6.3, -7.0, -4.8, -4.4, -4.8,
                  -6.8, -6.2, -6.2],
            "K": [-3.1, -3.6, -3.3 - -3.2, -4.4, -3.7, -3.8, -3.8, -4.1, -5.6, -4.6, -2.7, -4.7, -4.9, -3.6, -3.0, -3.3,
                  -5.0, -4.9, -4.2],
            "M": [-4.6, -5.0, -4.2, -4.3, -6.2, -3.5, -4.6, -5.1, -5.4, -7.4, -6.3, -4.7, -5.8, -6.6, -5.1, -4.1, -4.6,
                  -6.9, -6.1, -6.0],
            "F": [-5.1, -5.8, -5.0, -4.9, -6.8, -5.3, -5.0, -5.6, -6.4, -8.0, -7.0, -4.9, -6.6, -7.1, -5.2, -4.7, -5.1,
                  -7.4, -6.6, -6.5],
            "P": [-3.4, -4.2, -3.6, -3.3, -5.3, -4.0, -3.5, -4.2, -4.5, -6.0, -4.8, -3.6, -5.1, -5.2, -3.5, -3.4, -3.6,
                  -5.6, -5.2, -4.7],
            "S": [-2.9, -3.8, -3.1, -2.7, -4.6, -3.6, -3.2, -3.8, -4.2, -5.5, -5.5, -3.0, -4.1, -4.7, -3.4, -2.5, -3.3,
                  -5.0, -4.7, -4.2],
            "T": [-3.3, -4.0, -3.5, -3.1, -4.8, -3.7, -3.3, -4.1, -4.5, -5.9, -3.8, -3.3, -4.6, -5.1, -3.6, -3.3, -3.1,
                  -5.1, -4.9, -4.4],
            "W": [-5.2, -5.8, -5.3, -5.1, -6.9, -5.8, -5.2, -5.8, -6.5, -7.8, -6.8, -5.0, -6.9, -7.4, -5.6, -5.0, -5.1,
                  -6.8, -6.8, -6.5],
            "Y": [-4.7, -5.6, -5.0, -4.7, -6.6, -5.2, -4.9, -5.4, -6.1, -7.4, -6.2, -4.9, -6.1, -6.6, -5.2, -4.7, -4.9,
                  -6.8, -6.0, -5.9],
            "V": [-4.3, -4.9, -4.3, -4.0, -6.0, -4.7, -4.2, -5.1, -5.3, -7.3, -6.2, -4.2, -6.0, -6.5, -4.7, -4.2, -4.4,
                  -6.5, -5.9, -5.5],
            "X": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            }

        count = 0
        matrix_np = np.zeros((1000, 20), dtype=np.float64)
        for i in data:
            if count >= 1000:
                break
            else:
                matrix_np[count] = matrix[i]
                count += 1
        return matrix_np

    def miyazawa_energies(self, data):
        matrix = {
            "A": [-0.12, 0.24, 0.15, 0.27, -0.33, 0.22, 0.38, -0.08, 0.07, -0.37, -0.38, 0.41, -0.27, -0.36, 0.15, 0.1,
                  0.04, -0.27, -0.2, -0.32],
            "R": [0.24, 0.19, 0.1, -0.24, 0.08, 0.09, -0.22, 0.09, 0.05, 0.0, -0.04, 0.66, 0.03, -0.05, 0.17, 0.16,
                  0.11, -0.21, -0.25, 0.08],
            "N": [0.15, 0.1, -0.06, 0.02, -0.01, 0.06, 0.12, -0.01, 0.0, 0.14, 0.04, 0.22, 0.04, -0.01, 0.18, 0.09,
                  0.04, -0.1, -0.11, 0.12],
            "D": [0.27, -0.24, 0.02, 0.29, 0.12, 0.24, 0.44, 0.11, -0.1, 0.22, 0.27, -0.01, 0.3, 0.18, 0.33, 0.1, 0.11,
                  0.07, -0.07, 0.36],
            "C": [-0.33, 0.08, -0.01, 0.12, -1.19, -0.07, 0.2, -0.31, -0.36, -0.64, -0.65, 0.33, -0.61, -0.67, -0.18,
                  -0.13, -0.15, -0.66, -0.39, -0.59],
            "Q": [0.22, 0.09, 0.06, 0.24, -0.07, 0.2, 0.27, 0.13, 0.15, -0.01, -0.04, 0.28, -0.06, -0.11, 0.17, 0.22,
                  0.12, -0.02, -0.14, 0.08],
            "E": [0.38, -0.22, 0.12, 0.44, 0.2, 0.27, 0.46, 0.32, 0.0, 0.17, 0.17, -0.06, 0.12, 0.14, 0.37, 0.18, 0.16,
                  0.0, -0.08, 0.26],
            "G": [-0.08, 0.09, -0.01, 0.11, -0.31, 0.13, 0.32, -0.29, 0.0, -0.13, -0.16, 0.29, -0.17, -0.19, 0.02,
                  -0.01, -0.04, -0.25, -0.22, -0.15],
            "H": [0.07, 0.05, 0.0, -0.1, -0.36, 0.15, 0.0, 0.0, -0.4, -0.13, -0.18, 0.38, -0.29, -0.34, 0.01, 0.04,
                  -0.03, -0.37, -0.3, -0.06],
            "I": [-0.37, 0.0, 0.14, 0.22, -0.64, -0.01, 0.17, -0.13, -0.13, -0.74, -0.81, 0.24, -0.66, -0.73, -0.05,
                  0.03, -0.15, -0.6, -0.49, -0.67],
            "L": [-0.38, -0.04, 0.04, 0.27, -0.65, -0.04, 0.17, -0.16, -0.18, -0.81, -0.84, 0.22, -0.7, -0.8, -0.12,
                  -0.02, -0.15, -0.62, -0.55, -0.74],
            "K": [0.41, 0.66, 0.22, -0.01, 0.33, 0.28, -0.06, 0.29, 0.38, 0.24, 0.22, 0.76, 0.29, 0.19, 0.47, 0.36,
                  0.33, 0.09, -0.05, 0.29],
            "M": [-0.27, 0.03, 0.04, 0.3, -0.61, -0.06, 0.12, -0.17, -0.29, -0.66, -0.7, 0.29, -0.7, -0.83, -0.13, 0.05,
                  -0.11, -0.73, -0.56, -0.51],
            "F": [-0.36, -0.05, -0.01, 0.18, -0.67, -0.11, 0.14, -0.19, -0.34, -0.73, -0.8, 0.19, -0.83, -0.88, -0.19,
                  -0.12, -0.15, -0.68, -0.58, -0.67],
            "P": [0.15, 0.17, 0.18, 0.33, -0.18, 0.17, 0.37, 0.02, 0.01, -0.05, -0.12, 0.47, -0.13, -0.19, 0.11, 0.2,
                  0.13, -0.37, -0.25, -0.05],
            "S": [0.1, 0.16, 0.09, 0.1, -0.13, 0.22, 0.18, -0.01, 0.04, 0.03, -0.02, 0.36, 0.05, -0.12, 0.2, 0.05, 0.04,
                  -0.01, -0.08, 0.04],
            "T": [0.04, 0.11, 0.04, 0.11, -0.15, 0.12, 0.16, -0.04, -0.03, -0.15, -0.15, 0.33, -0.11, -0.15, 0.13, 0.04,
                  0.03, -0.02, -0.09, -0.07],
            "W": [-0.27, -0.21, -0.1, 0.07, -0.66, -0.02, 0.0, -0.25, -0.37, -0.6, -0.62, 0.09, -0.73, -0.68, -0.37,
                  -0.01, -0.02, -0.64, -0.49, -0.51],
            "Y": [-0.2, -0.25, -0.11, -0.07, -0.39, -0.14, -0.08, -0.22, -0.3, -0.49, -0.55, -0.05, -0.56, -0.58, -0.25,
                  -0.08, -0.09, -0.49, -0.45, -0.38],
            "V": [-0.32, 0.08, 0.12, 0.36, -0.59, 0.08, 0.26, -0.15, -0.06, -0.67, -0.74, 0.29, -0.51, -0.67, -0.05,
                  0.04, -0.07, -0.51, -0.38, -0.65],
            "X": [-0.03, 0.05, 0.05, 0.15, -0.31, 0.09, 0.17, -0.05, -0.09, -0.27, -0.3, 0.28, -0.27, -0.34, 0.05, 0.06,
                  0.01, -0.32, -0.29, -0.21]}

        count = 0
        matrix_np = np.zeros((1000, 20), dtype=np.float64)
        for i in data:
            if count >= 1000:
                break
            else:
                matrix_np[count] = matrix[i]
                count += 1
        return matrix_np

    def micheletti_potentials(self, data):
        matrix = {
            "A": [0.1461, -0.2511, 0.3323, -0.1348, -0.0751, 0.5029, -0.2376, -0.3111, -0.2432, -0.2119, 0.0864, 0.1754,
                  -0.1496, 0.5126, -0.5081, -0.1515, -0.0218, -0.9737, -0.0724, 0.3642],
            "R": [-0.2511, 0.9875, -0.6728, 0.1974, -0.6062, -0.121, -0.4586, 0.2466, 0.9985, 0.1034, -0.1302, 0.7273,
                  -0.4676, 0.4855, -0.0067, -0.118, 0.3967, -1.4845, 0.4237, -0.5168],
            "N": [0.3323, -0.6728, -0.1962, 0.7855, 0.6139, 0.4502, -0.3154, -0.1649, 0.8099, 0.2317, -0.0605, 0.6158,
                  1.8413, 0.3461, 0.3707, 0.6249, -0.5914, -0.3028, -0.6968, -0.104],
            "D": [-0.1348, 0.1974, 0.7855, -0.0531, 0.2278, -0.1466, 0.2194, 0.1528, -0.2501, 0.2659, 0.0585, -0.0642,
                  0.1491, 0.4899, 0.0755, -0.1609, 0.2193, -0.7832, 0.0182, 0.0092],
            "C": [-0.0751, -0.6062, 0.6139, 0.2278, -0.2544, 0.1387, 0.2791, 0.1847, 5.4553, 0.2965, -0.0196, -0.604,
                  1.4331, -1.3925, -0.172, 0.1837, 0.262, -3.5239, 0.2585, 0.0296],
            "Q": [0.5029, -0.121, 0.4502, -0.1466, 0.1387, 0.8438, -0.5234, -0.0425, 0.5803, -0.1875, -0.4168, 0.2349,
                  -0.2908, 0.379, 0.0525, -0.9002, 0.1006, 1.2075, -0.5137, 0.0029],
            "E": [-0.2376, -0.4586, -0.3154, 0.2194, 0.2791, -0.5234, 0.6456, -0.0113, -0.7232, 0.7647, -0.0453,
                  -0.9604, 0.3231, -0.1143, 0.5402, 0.2888, 0.0948, -0.9357, 0.3261, 0.1387],
            "G": [-0.3111, 0.2466, -0.1649, 0.1528, 0.1847, -0.0425, -0.0113, 0.099, -0.0951, 0.0446, -0.1538, -0.1308,
                  0.2339, 0.0189, 0.9071, -0.3528, 0.1084, -1.2366, -0.0737, 0.1995],
            "H": [-0.2432, 0.9985, 0.8099, -0.2501, 5.4553, 0.5803, -0.7232, -0.0951, 0.1314, -0.0476, -0.4529, 0.2934,
                  3.1785, -0.019, -0.2032, 0.9858, -0.5871, -0.6739, 0.7276, -0.6893],
            "I": [-0.2119, 0.1034, 0.2317, 0.2659, 0.2965, -0.1875, 0.7647, 0.0446, -0.0476, 0.6801, -0.0782, 0.0855,
                  -0.9283, -0.9792, 0.4353, 0.1538, -0.4179, 0.2734, -0.4792, 0.2618],
            "L": [0.0864, -0.1302, -0.0605, 0.0585, -0.0196, -0.4168, -0.0453, -0.1538, -0.4529, -0.0782, -0.0748,
                  0.2119, -0.2531, -0.2127, -0.5026, 0.1004, 0.377, 1.0659, 0.354, -0.194],
            "K": [0.1754, 0.7273, 0.6158, -0.0642, -0.604, 0.2349, -0.9604, -0.1308, 0.2934, 0.0855, 0.2119, 0.5109,
                  -0.4667, -0.4479, 0.9888, 0.5015, -0.5895, -0.1668, 0.7956, -0.6987],
            "M": [-0.1496, -0.4676, 1.8413, 0.1491, 1.4331, -0.2908, 0.3231, 0.2339, 3.1785, -0.9283, -0.2531, -0.4667,
                  3.1655, 0.101, -0.8698, 0.2007, -0.219, 98.4886, -0.3258, -0.5331],
            "F": [0.5126, 0.4855, 0.3461, 0.4899, -1.3925, 0.379, -0.1143, 0.0189, -0.019, -0.9792, -0.2127, -0.4479,
                  0.101, -1.3128, -0.6986, -0.1223, 0.4102, 0.6057, -0.3256, 0.0008],
            "P": [-0.5081, -0.0067, 0.3707, 0.0755, -0.172, 0.0525, 0.5402, 0.9071, -0.2032, 0.4353, -0.5026, 0.9888,
                  -0.8698, -0.6986, -0.3621, -0.3125, 0.5402, 1.3914, 0.0996, 0.1362],
            "S": [-0.1515, -0.118, 0.6249, -0.1609, 0.1837, -0.9002, 0.2888, -0.3528, 0.9858, 0.1538, 0.1004, 0.5015,
                  0.2007, -0.1223, -0.3125, -0.0802, -0.2393, -0.233, -0.1895, -0.0443],
            "T": [-0.0218, 0.3967, -0.5914, 0.2193, 0.262, 0.1006, 0.0948, 0.1084, -0.5871, -0.4179, 0.377, -0.5895,
                  -0.219, 0.4102, 0.5402, -0.2393, 0.3269, 0.3848, -0.1235, 0.4075],
            "W": [-0.9737, -1.4845, -0.3028, -0.7832, -3.5239, 1.2075, -0.9357, -1.2366, -0.6739, 0.2734, 1.0659,
                  -0.1668, 98.4886, 0.6057, 1.3914, -0.233, 0.3848, 13.1813, 0.3708, -0.1516],
            "Y": [-0.0724, 0.4237, -0.6968, 0.0182, 0.2585, -0.5137, 0.3261, -0.0737, 0.7276, -0.4792, 0.354, 0.7956,
                  -0.3258, -0.3256, 0.0996, -0.1895, -0.1235, 0.3708, -0.7699, -0.2175],
            "V": [0.3642, -0.5168, -0.104, 0.0092, 0.0296, 0.0029, 0.1387, 0.1995, -0.6893, 0.2618, -0.194, -0.6987,
                  -0.5331, 0.0008, 0.1362, -0.0443, 0.4075, -0.1516, -0.2175, 0.1445],
            "X": [-0.06, -0.01, 0.2, 0.06, 0.14, 0.07, -0.04, -0.02, 0.46, 0.01, -0.02, 0.05, 5.23, -0.11, 0.1, 0.01,
                  0.04, 5.33, -0.02, -0.07]}

        count = 0
        matrix_np = np.zeros((1000, 20), dtype=np.float64)
        for i in data:
            if count >= 1000:
                break
            else:
                matrix_np[count] = matrix[i]
                count += 1
        return matrix_np

    """
    Machine Learning Encoding
        AESNN3
        ANN4D
        ProtVec
        ProtVer-3mer

        Riis And krogh -Improving Prediction of Protein Secondary Structure using Structured Neural Networks and Multiple Sequence Alignments, are not include matrix table or somethings
        Jagla and Schuchhardt - Adaptive encoding neural networks for the recognition of human signal pepetide cleavage sites, are not include matrix table or somethings
        Meiler - Generation and evaluation of dimension-reduced amino acid parameter representations by artificial neural networks are almost same ann4d
        Lin - Amino Acid Encoding Schemes from Protein Structure Alignments: Multi-dimensional Vectors to Describe Residue Types are almost same aesnn3
    """

    def aesnn3(self, data):
        matrix = {"A": [-0.99, -0.61, 0.00], "R": [0.28, -0.99, -0.22], "N": [0.77, -0.24, 0.59],
                  "D": [0.74, -0.72, -0.35], "C": [0.34, 0.88, 0.35], "Q": [0.12, -0.99, -0.99],
                  "E": [0.59, -0.55, -0.99], "G": [-0.79, -0.99, 0.10], "H": [0.08, -0.71, 0.68],
                  "I": [-0.77, 0.67, -0.37], "L": [-0.92, 0.31, -0.99], "K": [-0.63, 0.25, 0.50],
                  "M": [-0.80, 0.44, -0.71], "F": [0.87, 0.65, -0.53], "P": [-0.99, -0.99, -0.99],
                  "S": [0.99, 0.40, 0.37], "T": [0.42, 0.21, 0.97], "W": [-0.13, 0.77, -0.90],
                  "Y": [0.59, 0.33, -0.99], "V": [-0.99, 0.27, -0.52], "X": [-0.06, -0.08, -0.25]
                  }
        count = 0
        matrix_np = np.zeros((1000, 3), dtype=np.float64)
        for i in data:
            if count >= 1000:
                break
            else:
                matrix_np[count] = matrix[i]
                count += 1
        return matrix_np

    def ann4d(self, data):
        matrix = {"A": [0.56, 1, 0.86, 0.19], "G": [0.05, 0.7, 0.59, 0.17], "V": [0.48, 0.77, 0.3, 0.99],
                  "L": [0.7, 0.78, 0.89, 0.49], "I": [0.94, 0.83, 0.35, 1], "F": [0.69, 0.5, 0.81, 0.58],
                  "Y": [0.58, 0.23, 0.7, 0.52], "W": [1, 0.37, 0.89, 0.66], "T": [0.23, 0.55, 0.38, 0.67],
                  "S": [0.19, 0.55, 0.57, 0.41], "R": [0.34, 0, 1, 0.01], "K": [0.27, 0.11, 0.86, 0.08],
                  "H": [0.39, 0.25, 0.76, 0.39], "D": [0.51, 0.41, 0.11, 0], "E": [0.9, 0.87, 0.32, 0.01],
                  "N": [0.19, 0.18, 0.68, 0.18], "Q": [0.46, 0.49, 0.84, 0.21], "M": [0.66, 0.67, 0.89, 0.42],
                  "P": [0, 0.82, 0, 0.99], "C": [0.09, 0.54, 0.65, 0.74], "X": [0.46, 0.53, 0.62, 0.44]
                  }
        count = 0
        matrix_np = np.zeros((1000, 4), dtype=np.float64)
        for i in data:
            if count >= 1000:
                break
            else:
                matrix_np[count] = matrix[i]
                count += 1
        return matrix_np

    def protvec(self, data):
#         from protvec import trigram

        trigram_data = self.trigram(data)

        import json
        with open('/home/kyung/Plastic/plastic_model/tools/ProtVec.json', 'r') as f:
            json_data = json.load(f)

        count = 0
        matrix_np = np.zeros((300, 100), dtype=np.float64)
        
        for i in trigram_data:
            matrix = list(map(float, json_data[i]))
            if count >= 300:
                break
            else:
                matrix_np[count] = matrix
                count += 1
                
        return matrix_np
    
    def trigram(self, data):
        word_list = list()
        n_value = 3
        for i in range(0, len(data) - 3, 3):
            a = data[i:n_value]
            b = data[i + 1:n_value + 1]
            c = data[i + 2:n_value + 2]

            if len(a) == 3:
                word_list.append(a)
            if len(b) == 3:
                word_list.append(b)
            if len(c) == 3:
                word_list.append(data[i + 2:n_value + 2])
            # word_list = list(set(word_list))

            n_value += 3

        return sorted(word_list)

    def make_corpus(self, data, n_value):
        corpus = list()
        for i in data:
            corpus.append(trigram(i, n_value))
            # print(corpus)
        return corpus
